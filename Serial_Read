#include <string.h>

int led = 9;

// Drive and steering motor command bytes from remote control:
byte stop[] = {
  0xFF, 0x00, 0x00, 0x00, 0xFE};
byte forward[] = {
  0xFF, 0x00, 0x01, 0x00, 0xFE};
byte backward[] = {
  0xFF, 0x00, 0x02, 0x00, 0xFE};
byte left[] = {
  0xFF, 0x00, 0x04, 0x00, 0xFE};
byte right[] = {
  0xFF, 0x00, 0x08, 0x00, 0xFE};

// Vacuum motor commands from remote control:
byte suckOff[] = {
  0xFF, 0x01, 0x00, 0x00, 0xFE};
byte suckOn[] = {
  0xFF, 0x01, 0x01, 0x00, 0xFE};


// Wash commands from remote control:

// Camera commands from remote control:

// Blank array to store captured command:
byte capturedByte[] = {
  00, 00, 00, 00, 00};

// Variables for counting:
int i = 0;
int j = 0;
int k = 0;
int m = 0;

// Command variables for switch statements:
int driveCommand = 0;
int vacuumCommand = 0;
int washCommand = 0;
int cameraCommand = 0;

void setup()
{

  pinMode(led, OUTPUT);

  /*
  Now we want to get the serialInterrupt to work on Serial 2; 
  This page gives ideas but I haven't tried yet:
  http://support.robotis.com/en/software/robotis_opencm/learning/serial_communication.htm
  */
  SerialUSB.attachInterrupt(usbInterrupt);

}

void loop(){
  delay(1000);
}

// Main interrupt waiting for remote control command:
// USB max packet data is maximum 64byte, so nCount can not exceeds 64 bytes
void usbInterrupt(byte* buffer, byte nCount){

  // Load buffer into capturedByte
  for( int i = 0; i < nCount; i++ )
  {
    //SerialUSB.print((char)buffer[i]);

    //Loads buffer into capturedByte
    capturedByte[i] = buffer[i];
  }
  //SerialUSB.print("nCount is: ");
  //SerialUSB.println(nCount);

  SerialUSB.print("Captured Byte is: ");
  for (j = 0; j < sizeof(capturedByte); j++)
  {
    SerialUSB.print(capturedByte[j], HEX);
  }

  // Series of IF statements to determine command:

  // All commands begin with FF, else command will be called invalid
  // 0. Check for FF:
  if (capturedByte[0] == forward[0])
  {

    // 1. Check for drive/steering(0x00) or suction(0x01):
    if (capturedByte[1] == forward[1])
    {
      // DRIVE could be correct, as long as capturedByte[4] is FE, which we can check below as in case 0, but it's not necessary
      // 2. Byte index 2 chooses switch for stop(0x00), forward(0x01), backward(0x02), left(0x04), right(0x08)
      driveCommand = capturedByte[2];
      switch(driveCommand)
      {
      case 0:
        if (capturedByte[4] == forward[4])
        {
          //STOP
          SerialUSB.println("You have stopped.");
        }else{         
          break;
        }
      case 1:
        if (capturedByte[4] == forward[4])
        {
          // FORWARD
          SerialUSB.println("You are going forward.");
        }else{
        break;
        }
      case 2:
        // BACKWARD
        break;
      case 4:
        // LEFT
        break;
      case 8:
        // RIGHT
       break; 
      default: 
        // ?
        break;
      }

    }//CLOSE if 1 check
    else
    {
      // Vacuum command is selected (0x01)
      // Byte index 2 will set vacuum intensity
      
      vacuumCommand = capturedByte[2];
      switch(vacuumCommand)
      {
        case 0:
          // Sucking is turned OFF
          break;
        case 1:
          // Sucking is turned ON
          break;
        default:
          // Invalid sucking command
          break;
      }// CLOSE SUCK switch
    }// CLOSE else 1
  }//CLOSE if 0 check
  
  // If first command index is not FF, it is not a command
  else
  {
    SerialUSB.println("Invalid command");  
  }//CLOSE else 0
  
  
  
// Old code used to test hex values received; we probably don't need this:
//  // Compare capturedByte to all commands and choose one command from a BIG SWITCH statement
//  for( k = 0; k < sizeof(capturedByte); k++ )
//  {
//    if ( capturedByte[k] == forward[k] )
//    {
//      m = m + 1;
//    }
//    else
//    {
//    }
//  }// Close k for loop
//
//  SerialUSB.print("m equals: ");
//  SerialUSB.println(m);
//  if (m == 5)
//  {
//    SerialUSB.print("You go forward");
//  }
//  else{
//  }

}// CLOSE void interrupt

void blink()
{
  digitalWrite(led, HIGH);
  delay(500);
  digitalWrite(led, LOW);
  delay(500);
}


